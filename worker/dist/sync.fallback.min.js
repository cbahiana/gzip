!function(){"use strict";const e=(e,t)=>t instanceof Response&&("cors"==t.type||new URL(e.url,self.origin).origin==self.origin)&&"GET"==e.method&&t.ok&&["default","cors","basic","navigate"].includes(t.type)&&!t.bodyUsed,t=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"],n=new class{async push(e){const n=await this.cloneRequestData(e),r=await this.getDB();return await r.put({id:function(e){var t,n=0;if(0===e.length)return n;for(t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return(+n).toString(36)}(e.url+t.map(async e=>{let t=n[e];return null==t?"":"headers"==e?t instanceof Headers?[...t.values()].filter(e=>null!=e).join(""):Object.values(t).map(t=>null!=n[e][t]?n[e][t]:"").join(""):"body"==e?await t.text():t}).join("")),lastRetry:Date.now()+864e5,url:e.url,request:n}),this}async cloneRequestData(e){const n={headers:{}};"GET"!==e.method&&(n.body=await e.clone().arrayBuffer());for(const[t,r]of e.headers.entries())n.headers[t]=r;for(const r of t)void 0!==e[r]&&(n[r]=e[r]);return"navigate"===n.mode&&(n.mode="same-origin"),n}async getDB(){return null==this.db&&(this.db=await async function(e,t="id",n=[]){return new Promise((r,o)=>{const s=indexedDB.open(e,1),a=`${e}_store`;let i;const c=(e,t,n=null,r=null)=>new Promise((o,s)=>{const c=t?"readonly":"readwrite";if(i.objectStoreNames.contains(a)){const t=i.transaction(a,c),l=t.objectStore(a);let u;"put"===e&&n&&void 0!==n.length?(u=t,n.forEach(e=>{l.put(e)})):(r&&l.index(r),u=l[e](n)),u.oncomplete=(e=>{o(e.target.result)}),u.onsuccess=(e=>{o(e.target.result)}),u.onerror=(e=>{s(e)})}else s(Error("Store not found"))}),l={count:async()=>{const e=i.transaction(a,"readonly").objectStore(a).count();return new Promise(function(t,n){e.onsuccess=function(e){t(e.target.result)},e.onerror=function(e){n(e)}})},get:(e,t)=>c("get",!0,e,t),getAll:(e,t)=>c("getAll",!0,e,t),put:e=>c("put",!1,e),delete:e=>c("delete",!1,e),clear:()=>c("clear",!1),deleteDatabase:()=>new Promise(function(e,t){const n=indexedDB.deleteDatabase;n.onerror=t,n.onsuccess=e})};s.onupgradeneeded=(()=>{const e=(i=s.result).createObjectStore(a,{keyPath:t});let r;for(r of n)e.createIndex(r.name,r.key,r.options)}).bind(this),s.onsuccess=(()=>{i=s.result,r(l)}).bind(this),s.onerror=(e=>{o(Error(e.originalTarget&&e.originalTarget.error||e))}).bind(this)})}("gzip_sw_worker_sync_requests","id")),this.db}async replay(t){if("{SYNC_API_TAG}"!=t)return;const n=await this.getDB(),r=await n.getAll();r.length>0&&console.info("attempting to sync background requests ...");const o=await caches.open("{CACHE_NAME}");for(const t of r){let r=!1;try{console.info("attempting to replay background requests: ["+t.request.method+"] "+t.url);const n=new Request(t.url,t.request);let s=await o.match(n);(r=null!=s)||(r=null!=(s=await fetch(n.clone()))&&s.ok)&&e(n,s)&&await o.put(n,s)}catch(e){}!r&&t.lastRetry>Date.now()||await n.delete(t.id)}}};let r=0;const o=function(e=1){return e*=3600,function(t){return 1e3*Math.min(e,.5*(2**t-1))}}();setTimeout(async function e(){await n.replay("{SYNC_API_TAG}"),setTimeout(e,o(++r))},o(r))}();
