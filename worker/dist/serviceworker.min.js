"use strict;";"{IMPORT_SCRIPTS}";const e=null,t=Object.create(e),s="{CACHE_NAME}";!function(){const s={implement(e){const t=e.prototype,s=[].slice.call(arguments,1);let n,o,a;function i(e,t,s){return function(){const r="previous"in this,n="parent"in this,o=this.previous,a=this.parent;this.previous=t,this.parent=s;const i=e.apply(this,arguments);return r&&(this.previous=o),n&&(this.parent=a),i}}for(n=0;n<s.length;n++)for(a in s[n])switch(typeof(o=s[n][a])){case"function":t[a]=i(o,e[a],t[a]);break;case"object":t[a]=r(!0,Array.isArray(o)?[]:{},o);break;default:t[a]=o}return e},merge:r,reset:function t(n){const o=s.getAllPropertiesName(n);let a,i,c=o.length;for(;c&&c--;)a=o[c],i=Object.getOwnPropertyDescriptor(n,a),n[a]!=e&&"object"==typeof n[a]&&i!=e&&"value"in i&&i.writable&&i.configurable&&(n[a]=r(!0,Array.isArray(n[a])?[]:{},t(n[a])));return n},extendArgs:e=>(function(t){if("object"==typeof t){const s=[].slice.call(arguments,1);let r;for(r in t)e.apply(this,[r,t[r]].concat(s))}else e.apply(this,arguments);return this}),getAllPropertiesName(e){const t=[];let s,r,n,o=e;do{for(s=Object.getOwnPropertyNames(o),n=0;n<s.length;n++)r=s[n],-1===t.indexOf(r)&&t.push(r)}while(o=Object.getPrototypeOf(o));return t}};function r(t){const s=[].slice.call(arguments,1);let n,o,a,i,c="boolean"==typeof t;for(!0===c&&(c=t,t=s.shift()),n=0;n<s.length;n++)if((o=s[n])!=e)for(a in o)switch(typeof(i=o[a])){case"object":t[a]=i!=e&&c?r(c,"object"==typeof t[a]&&t[a]!=e?t[a]:Array.isArray(i)?[]:{},i):i;break;default:t[a]=i}return t}t.Utils=s}(),function(){const s=t.Utils,r=s.extendArgs,n={$events:{},$pseudo:{},promisify:r(function(t,s,r){const n=this;if(s==e)return;let o,a;const i=t=t.toLowerCase(),c={fn:s,cb:s,name:t,original:t,parsed:[t]};if(-1!=t.indexOf(":")){const s=t.match(/([^:]+):([^(]+)(\(([^)]+)\))?/);s==e?c.name=t=t.split(":",1)[0]:(c.original=t,c.name=s[1],c.parsed=s,t=s[1],s[2]in n.$pseudo&&n.$pseudo[s[2]](c))}t in n.$events||(n.$events[t]=[]),o=n.$events[t].length;for(;o&&o--;)if((a=n.$events[t][o]).fn==s&&a.original==i)return;Object.defineProperty(c,"sticky",{value:!!r}),n.$events[t].push(c)}),off:r(function(e,t,s){const r=this;let n,o;e=e.toLowerCase().split(":",1)[0];const a=r.$events[e];if(void 0!=a){for(s=!!s,o=a.length;o&&o--;)n=a[o],(void 0!=t||s)&&(n.fn!=t||n.sticky&&n.sticky!=s)||r.$events[e].splice(o,1);0==a.length&&delete r.$events[e]}}),resolve(e){e=e.toLowerCase();const t=this,s=arguments.length>1?[].slice.call(arguments,1):[];return Promise.all((t.$events[e]||[]).concat().map(e=>new Promise(r=>{r(e.cb.apply(t,s))})))},addPseudo(e,t){return this.$pseudo[e]=t,this}};n.addPseudo("once",function(e){return e.cb=function(){const t=e.fn.apply(this,arguments);return this.off(e.name,e.fn),t},this}),t.PromiseEvent=n,s.merge(!0,t,n)}(),t.strategies=function(){const t=new Map,s={add:(r,n,o)=>t.set(r,{key:r,name:o==e?r:o,handle:async e=>{const t=await n(e);return t.type,e.request.mode,t.ok,t.bodyUsed,t&&t.type,s.isCacheableRequest(e.request,t),e.request.url,t&&t.url,t}}),keys:()=>t.keys(),values:()=>t.values(),entries:()=>t.entries(),get:e=>t.get(e),has:e=>t.has(e),delete:e=>t.delete(e),isCacheableRequest:(t,s)=>s!=e&&("cors"==s.type||new URL(t.url,self.origin).origin==self.origin)&&"GET"==t.method&&s.ok&&["default","cors","basic","navigate"].includes(s.type)&&!s.bodyUsed};return s[Symbol.iterator]=(()=>t[Symbol.iterator]()),Object.defineProperty(s,"size",{get:()=>t.size}),s}(),t.strategies.add("nf",async r=>{try{const n=await fetch(r.request);if(n==e)throw new Error("Network error");if(t.strategies.isCacheableRequest(r.request,n)){const e=n.clone();caches.open(s).then(function(t){t.put(r.request,e)})}return n}catch(e){}return caches.match(r.request,{cacheName:s})},"Network fallback to Cache"),t.strategies.add("cf",async r=>{let n=await caches.match(r.request,{cacheName:s});if(n!=e)return n;if(n=await fetch(r.request),t.strategies.isCacheableRequest(r.request,n)){const e=n.clone();caches.open(s).then(function(t){t.put(r.request,e)})}return n},"Cache fallback to Network"),t.strategies.add("cn",async e=>{const r=await caches.match(e.request,{cacheName:s}),n=fetch(e.request).then(r=>{if(t.strategies.isCacheableRequest(e.request,r)){const t=r.clone();caches.open(s).then(function(s){s.put(e.request,t)})}return r});return r||n},"Cache and Network Update"),t.strategies.add("no",e=>fetch(e.request),"Network Only"),t.strategies.add("co",e=>caches.match(e.request,{cacheName:s},"Cache Only")),function(t){function s(t){return t==e||"HEAD"==t?"GET":t.toLowerCase()}new WeakMap;class r{constructor(s,r,n){const o=this;t.Utils.reset(o),o.options=Object.assign(Object.create({plugins:[]}),n||{}),o.path=s,o.strategy=r.name,o.handler={handle:async t=>{let s,n,a;try{for(n of s=await o.resolve("beforeroute",t))if(n!=e&&n instanceof Response)return n}catch(e){console.error("ðŸ˜­",error)}for(a of(n=await r.handle(t),s=await o.resolve("afterroute",t,n)))if(a!=e&&a instanceof Response)return a;return n}}}}t.Utils.merge(!0,r.prototype,t.PromiseEvent),r.RegExpRouter=class extends r{match(e){const t=e.request.url;return/^https?:/.test(t)&&this.path.test(t)}},r.ExpressRouter=class extends r{constructor(e,t,s){super(e,t,s),this.url=new URL(e,self.origin)}match(e){const t=e.request.url,s=new URL(t);return/^https?:/.test(t)&&s.origin==this.url.origin&&0==s.pathname.indexOf(this.url.pathname)}},r.CallbackRouter=class extends r{match(e){return this.path(e.request.url,e)}},t.Router=r,t.route=new class{constructor(){this.routers=Object.create(e),this.defaultHandler=Object.create(e)}getRouter(t){const s=t!=e&&t.request.method||"GET",r=this.routers[s]||[],n=r.length;let o,a=0;for(;n>a;a++)if((o=r[a]).match(t))return o.strategy,o.constructor.name,t.request.url,o.path,o;return this.defaultHandler[s]}registerRoute(t,r,n){return(n=s(n))in this.routers||(this.routers[n]=[]),r!=e&&t.setOptions(r),this.routers[n].push(t),this}unregisterRoute(e,t){t=s(t);const r=this.routers[t]||[],n=r.indexOf(e);return-1!=n&&r.splice(n,1),this}setDefaultHandler(e,t,r){this.defaultHandler[s(r)]={handler:e,options:t}}}}(t);const r=t.strategies,n=t.Router,o=t.route;let a,i="{defaultStrategy}";for(a of"{exclude_urls}")o.registerRoute(new n.RegExpRouter(new RegExp(a),r.get("no")));for(a of"{network_strategies}")o.registerRoute(new n.RegExpRouter(new RegExp(a[1],"i"),r.get(a[0])));for(a of r)o.registerRoute(new n.ExpressRouter("{scope}/media/z/"+a[0]+"/",a[1]));r.has(i)||(i="no"),o.setDefaultHandler(r.get(i)),self.addEventListener("install",e=>{e.waitUntil(caches.open(s).then(async e=>(await e.addAll("{preloaded_urls}"),await t.resolve("install"),self.skipWaiting())))}),self.addEventListener("activate",e=>{e.waitUntil(self.clients.claim().then(async()=>{const e=await caches.keys(),r=s.split(/_/,2),n=2==r.length&&r[0]+"_";return 0!=n&&await Promise.all(e.map(e=>0==e.indexOf(n)&&e!=s&&caches.delete(e))),t.resolve("activate")}))}),self.addEventListener("fetch",s=>{const r=t.route.getRouter(s);r!=e&&s.respondWith(r.handler.handle(s).catch(e=>(console.error("ðŸ˜­",e),fetch(s.request))))});
