"use strict;";"{IMPORT_SCRIPTS}";const e=null,t=Object.create(e),r="{CACHE_NAME}",s="ðŸ˜­";(function(){const r={implement(e){const t=e.prototype,r=[].slice.call(arguments,1);let n,o,a;function i(e,t,r){return function(){const s="previous"in this,n="parent"in this,o=this.previous,a=this.parent;this.previous=t,this.parent=r;const i=e.apply(this,arguments);return s&&(this.previous=o),n&&(this.parent=a),i}}for(n=0;n<r.length;n++)for(a in r[n])switch(typeof(o=r[n][a])){case"function":t[a]=i(o,e[a],t[a]);break;case"object":t[a]=s(!0,Array.isArray(o)?[]:{},o);break;default:t[a]=o}return e},merge:s,reset:function t(n){const o=r.getAllPropertiesName(n);let a,i,c=o.length;for(;c&&c--;)a=o[c],i=Object.getOwnPropertyDescriptor(n,a),n[a]!=e&&"object"==typeof n[a]&&i!=e&&"value"in i&&i.writable&&i.configurable&&(n[a]=s(!0,Array.isArray(n[a])?[]:{},t(n[a])));return n},extendArgs:e=>(function(t){if("object"==typeof t){const r=[].slice.call(arguments,1);let s;for(s in t)e.apply(this,[s,t[s]].concat(r))}else e.apply(this,arguments);return this}),getAllPropertiesName(e){const t=[];let r,s,n,o=e;do{for(r=Object.getOwnPropertyNames(o),n=0;n<r.length;n++)s=r[n],-1===t.indexOf(s)&&t.push(s)}while(o=Object.getPrototypeOf(o));return t}};function s(t){const r=[].slice.call(arguments,1);let n,o,a,i,c="boolean"==typeof t;for(!0===c&&(c=t,t=r.shift()),n=0;n<r.length;n++)if((o=r[n])!=e)for(a in o)switch(typeof(i=o[a])){case"object":t[a]=i!=e&&c?s(c,"object"==typeof t[a]&&t[a]!=e?t[a]:Array.isArray(i)?[]:{},i):i;break;default:t[a]=i}return t}t.Utils=r})(),function(){const r=t.Utils,s=r.extendArgs,n={$events:{},$pseudo:{},on:s(function(t,r,s){const n=this;if(r==e)return;let o,a;const i=t=t.toLowerCase(),c={fn:r,cb:r,name:t,original:t,parsed:[t]};if(-1!=t.indexOf(":")){const r=t.match(/([^:]+):([^(]+)(\(([^)]+)\))?/);r==e?c.name=t=t.split(":",1)[0]:(c.original=t,c.name=r[1],c.parsed=r,t=r[1],r[2]in n.$pseudo&&n.$pseudo[r[2]](c))}t in n.$events||(n.$events[t]=[]),o=n.$events[t].length;for(;o&&o--;)if((a=n.$events[t][o]).fn==r&&a.original==i)return;Object.defineProperty(c,"sticky",{value:!!s}),n.$events[t].push(c)}),off:s(function(e,t,r){const s=this;let n,o;e=e.toLowerCase().split(":",1)[0];const a=s.$events[e];if(void 0!=a){for(r=!!r,o=a.length;o&&o--;)n=a[o],(void 0!=t||r)&&(n.fn!=t||n.sticky&&n.sticky!=r)||s.$events[e].splice(o,1);0==a.length&&delete s.$events[e]}}),resolve(e){e=e.toLowerCase();const t=this,r=arguments.length>1?[].slice.call(arguments,1):[];return Promise.all((t.$events[e]||[]).concat().map(e=>new Promise(s=>{s(e.cb.apply(t,r))})))},addPseudo(e,t){return this.$pseudo[e]=t,this}};n.addPseudo("once",function(e){return e.cb=function(){const t=e.fn.apply(this,arguments);return this.off(e.name,e.fn),t},this}),t.PromiseEvent=n,r.merge(!0,t,n)}(),t.strategies=function(){const t=new Map,r={add:(s,n,o)=>t.set(s,{key:s,name:o==e?s:o,handle:async e=>{const t=await n(e);return t.type,e.request.mode,t.ok,t.bodyUsed,t&&t.type,r.isCacheableRequest(e.request,t),e.request.url,t&&t.url,t}}),keys:()=>t.keys(),values:()=>t.values(),entries:()=>t.entries(),get:e=>t.get(e),has:e=>t.has(e),delete:e=>t.delete(e),isCacheableRequest:(t,r)=>r!=e&&("cors"==r.type||new URL(t.url,self.origin).origin==self.origin)&&"GET"==t.method&&r.ok&&["default","cors","basic","navigate"].includes(r.type)&&!r.bodyUsed};return r[Symbol.iterator]=(()=>t[Symbol.iterator]()),Object.defineProperty(r,"size",{get:()=>t.size}),r}(),t.strategies.add("nf",async s=>{try{const n=await fetch(s.request);if(n==e)throw new Error("Network error");if(t.strategies.isCacheableRequest(s.request,n)){const e=n.clone();caches.open(r).then(t=>t.put(s.request,e))}return n}catch(e){}return caches.match(s.request,{cacheName:r})},"Network fallback to Cache"),t.strategies.add("cf",async s=>{let n=await caches.match(s.request,{cacheName:r});if(n!=e)return n;if(n=await fetch(s.request),t.strategies.isCacheableRequest(s.request,n)){const e=n.clone();caches.open(r).then(t=>t.put(s.request,e))}return n},"Cache fallback to Network"),t.strategies.add("cn",async e=>{const s=await caches.match(e.request,{cacheName:r}),n=fetch(e.request).then(s=>{if(t.strategies.isCacheableRequest(e.request,s)){const t=s.clone();caches.open(r).then(r=>r.put(e.request,t))}return s});return s||n},"Cache and Network Update"),t.strategies.add("no",e=>fetch(e.request),"Network Only"),t.strategies.add("co",e=>caches.match(e.request,{cacheName:r},"Cache Only")),function(t){function r(t="GET"){return t==e||"HEAD"==t?"GET":t.toUpperCase()}new WeakMap;class n{constructor(e,r,n){const o=this;t.Utils.reset(o),o.options=Object.assign(Object.create({plugins:[]}),n||{}),o.path=e,o.strategy=r.name,o.handler={handle:async e=>{let t,n,a,i;try{for(i of o.options.plugins)i.precheck(e);for(n of t=await o.resolve("beforeroute",e))if(n instanceof Response)return n}catch(e){console.error(s,error)}for(a of(n=await r.handle(e),t=await o.resolve("afterroute",e,n)))if(a instanceof Response){for(i of o.options.plugins)i.postcheck(e,a);return a}return n}}}}t.Utils.merge(!0,n.prototype,t.PromiseEvent),n.RegExpRouter=class extends n{match(e){const t=e.request.url;return/^https?:/.test(t)&&this.path.test(t)}},n.ExpressRouter=class extends n{constructor(e,t,r){super(e,t,r),this.url=new URL(e,self.origin)}match(e){const t=e.request.url,r=new URL(t);return/^https?:/.test(t)&&r.origin==this.url.origin&&0==r.pathname.indexOf(this.url.pathname)}},n.CallbackRouter=class extends n{match(e){return this.path(e.request.url,e)}},t.Router=n,t.route=new class{constructor(){this.routers=Object.create(e),this.defaultRouter=Object.create(e)}getRouter(t){const r=t!=e&&t.request.method||"GET",s=this.routers[r]||[],n=s.length;let o,a=0;for(;n>a;a++)if((o=s[a]).match(t))return o.strategy,o.constructor.name,t.request.url,o.path,o;return this.defaultRouter[r]}registerRoute(e,t="GET"){return r(t),(t=r(t))in this.routers||(this.routers[t]=[]),this.routers[t].push(e),this}unregisterRoute(e,t){t=r(t);const s=this.routers[t]||[],n=s.indexOf(e);return-1!=n&&s.splice(n,1),this}setDefaultRouter(e,t){this.defaultRouter[r(t)]=e}}}(t),t.expiration=function(){const t=Object.create(e);return t.CacheExpiration=class{constructor(t){const r=this;this.limit=+t.limit||0,this.maxAge=+t.maxAge||0,function(e,t="id"){return new Promise((r,s)=>{const n=indexedDB.open(e,1),o=`${e}_store`;let a;const i=(e,t,r=null)=>new Promise((s,n)=>{const i=t?"readonly":"readwrite";if(a.objectStoreNames.contains(o)){const t=a.transaction(o,i),c=t.objectStore(o);let u;"put"===e&&r&&void 0!==r.length?(u=t,r.forEach(e=>{c.put(e)})):u=c[e](r),u.oncomplete=(e=>{s(e.target.result)}),u.onsuccess=(e=>{s(e.target.result)}),u.onerror=(e=>{n(e)})}else n(new Error("Store not found"))}),c={count:()=>i("count",!0,keyToUse),getEntry:e=>i("get",!0,e),getAll:e=>i("getAll",!0,e),put:e=>i("put",!1,e),deleteEntry:e=>i("delete",!1,e),flush:()=>i("clear",!1)};n.onupgradeneeded=(()=>{(a=n.result).createObjectStore(o,{keyPath:t})}).bind(this),n.onsuccess=(()=>{a=n.result,r(c)}).bind(this),n.onerror=(e=>{s(new Error(e))}).bind(this)})}(t.cacheName||"gzip_sw_worker_expiration_cache_private","url").then(t=>r.db=t instanceof Error?e:t)}async precheck(t){try{if(this.db==e)return!0;await this.db.getAll(t.request.url),await caches.open(r).then(e=>e.match(t.request))}catch(e){console.error(s,e)}return!0}async postcheck(e){return this.db.put({url:e.request.url,method:e.request.method,timestamp:Date.now()+this.maxAge})}},t}();const n=t.strategies,o=t.Router,a=t.route;let i,c,u="{defaultStrategy}";for(i of"{exclude_urls}")a.registerRoute(new o.RegExpRouter(new RegExp(i),n.get("no")));for(i of"{network_strategies}")c=i[2]||"{cacheExpiryStrategy}",a.registerRoute(new o.RegExpRouter(new RegExp(i[1],"i"),n.get(i[0]),c==e?c:{plugins:[new t.expiration.CacheExpiration(c)]}));for(i of n)a.registerRoute(new o.ExpressRouter("{scope}{ROUTE}/media/z/"+i[0]+"/",i[1]));n.has(u)||(u="no"),a.setDefaultRouter(new o.ExpressRouter("/",n.get(u))),self.addEventListener("install",e=>{e.waitUntil(caches.open(r).then(async e=>(await e.addAll("{preloaded_urls}"),await t.resolve("install"),self.skipWaiting())))}),self.addEventListener("activate",e=>{e.waitUntil(self.clients.claim().then(async()=>{const e=await caches.keys(),s=r.split(/_/,2),n=2==s.length&&s[0]+"_";return 0!=n&&await Promise.all(e.map(e=>0==e.indexOf(n)&&e!=r&&caches.delete(e))),t.resolve("activate")}))}),self.addEventListener("fetch",r=>{const n=t.route.getRouter(r);n!=e&&r.respondWith(n.handler.handle(r).catch(e=>(console.error(s,e),fetch(r.request))))});
